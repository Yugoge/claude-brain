#!/usr/bin/env python3
"""
Sync Related Rems from Backlinks Index

This script auto-populates the "## Related Rems" section in all Rem files
based on the bidirectional link graph stored in backlinks.json.

What it does:
1. Reads backlinks.json (generated by rebuild-backlinks.py)
2. For each Rem, collects all related concepts:
   - Direct forward links (links_to)
   - Direct backward links (linked_from)
   - Typed links (typed_links_to, typed_linked_from)
   - Inferred links (inferred_links_to)
3. Formats them as markdown links with relationship types
4. Writes/updates the "## Related Rems" section in each Rem file

Usage:
    python scripts/knowledge-graph/sync-related-rems-from-backlinks.py [--dry-run] [--verbose]

Requirements:
    - Up-to-date knowledge-base/_index/backlinks.json
    - Run rebuild-backlinks.py first if backlinks.json doesn't exist or is stale

Examples:
    # Preview changes
    python scripts/knowledge-graph/sync-related-rems-from-backlinks.py --dry-run --verbose

    # Apply changes
    python scripts/knowledge-graph/sync-related-rems-from-backlinks.py --verbose
"""

import json
import re
import sys
import argparse
from pathlib import Path
from typing import Dict, List, Set, Tuple

# Constants
ROOT = Path(__file__).parent.parent.parent
KB_DIR = ROOT / "knowledge-base"
IDX_FILE = KB_DIR / "_index" / "backlinks.json"


def load_backlinks_index() -> Tuple[Dict, Dict]:
    """
    Load backlinks.json and return links graph and concepts metadata.

    Returns:
        Tuple of (links_dict, concepts_dict)

    Raises:
        SystemExit if backlinks.json doesn't exist
    """
    if not IDX_FILE.exists():
        raise SystemExit(
            f"âŒ Error: {IDX_FILE} not found.\n"
            f"Run: python scripts/knowledge-graph/rebuild-backlinks.py"
        )

    with open(IDX_FILE, 'r', encoding='utf-8') as f:
        data = json.load(f)

    links = data.get('links', {})
    concepts = data.get('concepts', {})

    return links, concepts


def collect_related_rems(concept_id: str, links_data: Dict, concepts_meta: Dict) -> List[Tuple[str, str, str]]:
    """
    Collect all related Rems for a given concept.

    Args:
        concept_id: ID of the concept
        links_data: Links graph from backlinks.json
        concepts_meta: Concepts metadata from backlinks.json

    Returns:
        List of (rem_id, title, relation_type) tuples, deduplicated
    """
    if concept_id not in links_data:
        return []

    data = links_data[concept_id]
    related = []
    seen_ids = set()

    # Helper to add related Rem
    def add_related(rem_id: str, rel_type: str):
        if rem_id in seen_ids or rem_id == concept_id:
            return
        seen_ids.add(rem_id)
        meta = concepts_meta.get(rem_id, {})
        title = meta.get('title', rem_id)
        file_path = meta.get('file', '')
        related.append((rem_id, title, file_path, rel_type))

    # 1. Typed forward links (highest priority - explicit relationships)
    for typed_link in data.get('typed_links_to', []):
        rem_id = typed_link.get('to')
        rel_type = typed_link.get('type', 'related')
        if rem_id:
            add_related(rem_id, rel_type)

    # 2. Typed backward links
    for typed_link in data.get('typed_linked_from', []):
        rem_id = typed_link.get('from')
        rel_type = typed_link.get('type', 'related')
        if rem_id:
            add_related(rem_id, f"linked-from-{rel_type}")

    # 3. Direct forward links (untyped)
    for rem_id in data.get('links_to', []):
        add_related(rem_id, 'links-to')

    # 4. Direct backward links (untyped)
    for rem_id in data.get('linked_from', []):
        add_related(rem_id, 'linked-from')

    # 5. Inferred links (lowest priority - automatic discovery)
    for inferred in data.get('inferred_links_to', []):
        rem_id = inferred.get('to')
        via = inferred.get('via', '')
        if rem_id:
            rel_type = f"inferred-via-{via}" if via else "inferred"
            add_related(rem_id, rel_type)

    return related


def format_related_rems_section(related: List[Tuple[str, str, str, str]]) -> str:
    """
    Format Related Rems section as markdown.

    Args:
        related: List of (rem_id, title, file_path, relation_type) tuples

    Returns:
        Formatted markdown section
    """
    if not related:
        return "## Related Rems\n\n*(No related Rems found)*"

    lines = ["## Related Rems", ""]

    for rem_id, title, file_path, rel_type in related:
        # Format: - [Title](relative/path.md) {rel: type}
        lines.append(f"- [[{rem_id}]] {{rel: {rel_type}}}")

    return "\n".join(lines)


def update_rem_file(file_path: Path, new_section: str, dry_run: bool = False, verbose: bool = False) -> bool:
    """
    Update Related Rems section in a Rem file.

    Args:
        file_path: Path to Rem file
        new_section: New Related Rems section content
        dry_run: If True, don't actually modify file
        verbose: If True, print details

    Returns:
        True if file was modified (or would be in dry-run)
    """
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()

        # Find and replace existing Related Rems section
        # Pattern: ## Related Rems ... (until next ## or end of file)
        pattern = r'(##\s+Related\s+Rems\s*\n)(.*?)(?=\n##|\Z)'

        match = re.search(pattern, content, re.DOTALL | re.IGNORECASE)

        if match:
            # Replace existing section
            old_content = match.group(2).strip()
            new_content = new_section.split('\n', 2)[2] if '\n' in new_section else ""  # Skip header

            # Skip if content is the same
            if old_content == new_content.strip():
                return False

            modified = re.sub(pattern, new_section + '\n', content, count=1, flags=re.DOTALL | re.IGNORECASE)
        else:
            # Append new section at the end
            if not content.endswith('\n'):
                content += '\n'
            modified = content + '\n' + new_section + '\n'

        # Write if modified
        if modified != content:
            if not dry_run:
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write(modified)

            if verbose:
                rel_path = file_path.relative_to(KB_DIR)
                status = "[DRY RUN] Would update" if dry_run else "âœ“ Updated"
                print(f"{status}: {rel_path}")

            return True

        return False

    except Exception as e:
        print(f"Error processing {file_path}: {e}", file=sys.stderr)
        return False


def main():
    """Main entry point for sync-related-rems script."""
    parser = argparse.ArgumentParser(
        description='Sync Related Rems sections from backlinks index',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=__doc__
    )
    parser.add_argument('--dry-run', action='store_true',
                        help='Preview changes without modifying files')
    parser.add_argument('--verbose', action='store_true',
                        help='Enable verbose output')
    parser.add_argument('--concept-ids', nargs='+',
                        help='Only process specific concept IDs (optional)')

    args = parser.parse_args()

    # Load backlinks index
    print("Loading backlinks index...")
    links_data, concepts_meta = load_backlinks_index()
    print(f"Found {len(links_data)} concepts in backlinks index")

    if args.dry_run:
        print("\nâš ï¸  DRY RUN MODE - No files will be modified\n")

    # Determine which concepts to process
    if args.concept_ids:
        concept_ids = args.concept_ids
        print(f"Processing {len(concept_ids)} specific concepts")
    else:
        concept_ids = list(links_data.keys())
        print(f"Processing all {len(concept_ids)} concepts")

    # Process each concept
    updated_count = 0
    skipped_count = 0

    for concept_id in concept_ids:
        # Get concept metadata
        meta = concepts_meta.get(concept_id)
        if not meta:
            if args.verbose:
                print(f"âš ï¸  Warning: No metadata for concept '{concept_id}'", file=sys.stderr)
            skipped_count += 1
            continue

        file_rel = meta.get('file')
        if not file_rel:
            if args.verbose:
                print(f"âš ï¸  Warning: No file path for concept '{concept_id}'", file=sys.stderr)
            skipped_count += 1
            continue

        file_path = KB_DIR / file_rel
        if not file_path.exists():
            if args.verbose:
                print(f"âš ï¸  Warning: File not found: {file_path}", file=sys.stderr)
            skipped_count += 1
            continue

        # Collect related Rems
        related = collect_related_rems(concept_id, links_data, concepts_meta)

        # Format new section
        new_section = format_related_rems_section(related)

        # Update file
        if update_rem_file(file_path, new_section, dry_run=args.dry_run, verbose=args.verbose):
            updated_count += 1

    # Summary
    print()
    if args.dry_run:
        print(f"Would update {updated_count} files")
        print(f"Would skip {skipped_count} files (no metadata/file not found)")
        print("\nRun without --dry-run to apply changes")
    else:
        print(f"âœ… Updated {updated_count} files")
        print(f"â­ï¸  Skipped {skipped_count} files (no metadata/file not found)")

        if updated_count > 0:
            print(f"\nðŸ’¡ Next step:")
            print(f"   Run normalize-links.py to convert [[wikilinks]] to markdown links:")
            print(f"   python scripts/knowledge-graph/normalize-links.py --mode replace --verbose")

    return 0


if __name__ == '__main__':
    sys.exit(main())
